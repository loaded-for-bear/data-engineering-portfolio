# CDC（Change Data Capture）の4方式

データソースの変更（INSERT/UPDATE/DELETE）を検出する手法の比較。

## 1. スナップショット比較

2時点のデータを丸ごと比較して差分を出す。

- **必要条件**: 2時点分のスナップショットがあればOK。ソース側の協力不要
- **メリット**: ソースシステムの変更不要、実装がシンプル、確実に全差分を検出
- **デメリット**: 毎回全件読み込むのでI/Oとメモリが無駄、データ量に比例してコスト増
- **適するケース**: ソースがCSVエクスポートのみ対応、件数が少ない〜中規模

## 2. タイムスタンプベース

`updated_at` カラムを使って変更行だけ抽出する。

```sql
SELECT * FROM products WHERE updated_at > '2026-02-16 00:00:00'
```

- **必要条件**: ソース側に信頼できるタイムスタンプカラムが必要
- **メリット**: 変更行だけ読むので高速、I/O 最小限
- **デメリット**: DELETE を検出できない、タイムスタンプ未更新のバグで漏れるリスク
- **適するケース**: ソースDBに直接クエリ可能、削除が論理削除（is_deleted フラグ）の場合

## 3. ログベース（WAL / Binlog）

DBのトランザクションログを読み取り、変更イベントをリアルタイムに取得。

```
PostgreSQL WAL / MySQL Binlog → Debezium → Kafka → DWH
```

- **必要条件**: DBレプリケーションログへのアクセス権、Debezium等のツール
- **メリット**: リアルタイム、ソースDBに負荷をかけない、DELETE検出可能、変更順序も保持
- **デメリット**: インフラが複雑（Kafka + Debezium）、運用コスト高、DB固有の知識が必要
- **適するケース**: リアルタイム要件がある、大規模データ、本格的なデータ基盤

## 4. トリガーベース

DBトリガーで変更を別テーブル（change_log）に記録する。

```sql
CREATE TRIGGER product_change AFTER INSERT OR UPDATE OR DELETE ON products
FOR EACH ROW INSERT INTO change_log (product_id, action, changed_at, ...);
```

- **必要条件**: ソースDBのDDL変更権限
- **メリット**: 確実に全変更を記録、DELETE検出可能
- **デメリット**: ソースDBのパフォーマンスに影響、DDL変更権限が必要、基幹システムに手を入れるリスク
- **適するケース**: ソースDBを管理できる小規模システム

## 比較表

| 方式 | DELETE検出 | リアルタイム | ソース変更 | 実装コスト | 運用コスト |
|------|-----------|------------|-----------|-----------|-----------|
| スナップショット比較 | 可能 | 不可（バッチ） | 不要 | 低 | 中（全件I/O） |
| タイムスタンプ | 不可 | 準リアルタイム | 不要 | 低 | 低 |
| ログベース（WAL） | 可能 | リアルタイム | 不要 | 高 | 高 |
| トリガーベース | 可能 | リアルタイム | 必要 | 中 | 中 |

## 選定の考え方

1. **ソースDBにアクセスできるか？** → No ならスナップショット比較一択
2. **DELETE検出が必要か？** → Yes ならタイムスタンプベースは除外
3. **リアルタイム要件があるか？** → Yes ならログベースかトリガーベース
4. **ソースDBのDDL変更が可能か？** → No ならトリガーベースは除外
5. **インフラ運用のコストを許容できるか？** → No ならログベースは除外
